import pytest
import pytest_html
import random
from random import randint
from code.quicksort import quick_sort
from code.bubblesort import bubble_sort
import logging
import sys
import datetime
import string

sort = quick_sort

'''TEST_CASE_1-9: Test for generic scenarios with parametrization: This test takes in different input types as parameters and run them against sorting algorithm one by one. 
Pytest treats each parameters as a separate test and reports them Pass/Fail in the output. Input data includes empty array, single element in array,
positive integers, mix of negative and positive integers, mix of integers and floating point data, mix of floating point, negative and positive,
 string characters, repeated elements, string words'''
@pytest.mark.parametrize(
    "n,expected",
    [
        ([], []), #Scenario1: Check by passing an empty array, algorithm should return an empty array
        ([1], [1]),  # Scenario2: Check by passing single element in array, algorithm should return same element
        ([2,1, 9,0], [0,1,2,9]), #Scenario3: Check by passing positive integers as input, algorithm should return sorted list of same set of elements in ascending order
        ([2,-1,-5],[-5,-1,2]), #Scenario4: Check by passing mix of negative and positive integers, algorithm should return sorted list of same set of elements in ascending order
        ([2,1,1.8,0.5,0],[0,0.5,1,1.8,2]), #Scenario5: Check by passing mix of floating and integers as input, algorithm should return sorted list of same set of elements in ascending order
        ([1,-2.2,1.8,0.5,0],[-2.2,0,0.5,1,1.8 ]), #Scenario6: Check by passing floating, negative and integers as input, algorithm should return sorted list of same set of elements in ascending order
        ([1, 2, 2, 5, 4, 2, 4], [1, 2, 2, 2, 4, 4, 5]), #Scenario7: Check by passing repeated elements as input, algorithm should return sorted list of same set of elements in ascending order
        (['c','d','a','f'],['a','c','d','f']), #Scenario8: Check by passing String characters as input, algorithm should return sorted list of same set of elements in ascending order
        (['apple','drum','arm','foil'],['apple','arm','drum','foil']), #Scenario9: Check by passing words as input, algorithm should return sorted list of same set of elements in ascending order
    ],
)
def test_sort_generic_basic_tests(n, expected):
    assert sort(n) == expected





'''TEST_CASE_10: Random Integers test: This test takes in random integers as input types generated by random function, 
number of elements in the array is defined by the range function and run them against sorting algorithm. 
Algortithm should return sorted version of the passed unsorted array. For generating expected output, I have used Python built-in function - sorted()
So in summary, this test passes unsorted array to python built-in function [sorted()] and chosen sorting algorithm and expected result is both their outputs
are sorted and matches with each other'''
def test_sort_on_random_small_ints():
    items1 = [random.randint(-10,20) for i in range(50)] #random randint function generates int values between (-10,20), range function dictates number of elements in the array
    print(items1)
    sorted_items = sorted(items1)  #sorted() function is python in-built sorting function
    assert sort(items1) == sorted_items #comparing output of sort algorithm versus output of python built-in sorting function





'''TEST_CASE_11: Random Floating test: This test takes in random floating points as input types generated by random function, 
number of elements in the array is defined by the range function and run them against sorting algorithm. 
Algortithm should return sorted version of the passed unsorted array. For generating expected output, I have used Python built-in function - sorted()
So in summary, this test passes unsorted array to python built-in function [sorted()] and chosen sorting algorithm and expected result is both their outputs
are sorted and matches with each other'''
@pytest.mark.skipif(sys.version_info > (3,5),reason="Conditional test, don't run if python verson is more than 3.5")
def test_sort_on_random_small_floats():
    items1 = [round(random.uniform(-6.98765,900.45789), 8) for i in range(50)] #random uniform function generates floating point values, range function dictates number of elements in the input array
    print(items1)
    sorted_items = sorted(items1) #sorted() function is python in-built sorting function
    assert sort(items1) == sorted_items #comparing output of sort algorithm versus output of python built-in sorting function





'''TEST_CASE_12: Random String test: This test takes in random string as input types generated by random function, 
number of elements in the array is defined by the range function and run them against sorting algorithm. 
Algortithm should return sorted version of the passed unsorted array of string characters. For generating expected output, I have used Python built-in function - sorted()
So in summary, this test passes unsorted array to python built-in function [sorted()] and chosen sorting algorithm and expected result is both their outputs
are sorted and matches with each other'''
def test_sort_on_random_small_strings():
    items1 = ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.ascii_lowercase) for _ in range(7)) #random choice function generates mix of uppercase and lowercase strings, range function dictates the size of the string
    print(items1)
    sorted_items = sorted(items1) #sorted() function is python in-built sorting function
    assert sort(items1) == sorted_items #comparing the output of sort algorithm versus output of python built-in sorting function





'''TEST_CASE_13: Dictionary as input: This test takes in dictionary as input type, 
we are trying to sort this dictionary by its keys which are strings in below example,
Algortithm should sort this dictionary by keys. For generating expected output, I have used Python built-in function - sorted()
So in summary, this test passes a dictionary to python built-in function [sorted()] and chosen sorting algorithm and expected result is both their outputs
are sorted and matches with each other'''
def test_sort_on_dict_by_keys():
    d = {'one':1,'three':3,'five':5,'two':2,'four':4}  #sample dictionary to be sorted by its keys
    a = [(key, " :: ", value) for (key, value) in sorted(d.items())] #sorting of this dictionary by python built-in sorting() function
    print(a)
    b = [(key, " :: ", value) for (key, value) in sort(d.items())] #sorting of this dictionary by chosen sort algorithm
    print(b)
    assert a == b  #comparing the output of sort algorithm versus output of python built-in sorting function



'''TEST_CASE_14: Dictionary as input: This test takes in dictionary as input type, 
we are trying to sort this dictionary by its values which are numeric in below example,
Algortithm should sort this dictionary by values. For generating expected output, I have used Python built-in function - sorted()
So in summary, this test passes a dictionary to python built-in function [sorted()] and chosen sorting algorithm and expected result is both their outputs
are sorted and matches with each other'''
def test_sort_on_dict_by_value():
    d = {'one':1,'three':3,'five':5,'two':2,'four':4} #sample dictionary to be sorted by its values
    a = sorted(d.items(), key=lambda x: x[1]) #sorting of this dictionary by python built-in sorting() function
    print(a)
    b = sort(d.items(), key=lambda x: x[1])
    print(b)
    assert a == b #comparing the output of sort algorithm versus output of python built-in sorting function




'''TEST_CASE_15: Tuple test: This test takes in random tuple as input type generated by random function, 
number of elements in the array is defined by the range function and run them against sorting algorithm. 
Sorting algorithm should be able to take tuple as input and sort its elements'''
def test_sort_on_random_tuple():
    items1 = tuple(random.randint(-10,20) for i in range(50)) #generating tuple using random function
    print(items1)
    sorted_items = sorted(items1)  #sorting of this dictionary by python built-in sorting() function
    assert sort(items1) == sorted_items #comparing the output of sort algorithm versus output of python built-in sorting function




'''TEST_CASE_16: Non-Comparable Collection test: This test takes in array of mix of ints and strings as input types, 
and run them against sorting algorithm. 
As this is a blackbox test, we assume algorithm will handle this scenario, so we run an assert on the output'''
def test_sort_on_mix_array():
    items1 = ['b',2,'c',1,'a']
    expected = [1,2,'a','b','c']
    assert sort(items1) == expected




'''TEST_CASE_17: Performance Test by passing a large size int array: This test takes in a big size array with integers as input types generated by random function, 
number of elements in the array is defined by the range function and run them against sorting algorithm. 
Algortithm should return sorted version of the passed unsorted array in a reasonable time. For generating expected output, I have used Python built-in function - sorted()
So in summary, this test passes unsorted array to python built-in function [sorted()] and chosen sorting algorithm and expected result is both their outputs
are sorted and matches with each other'''
@pytest.mark.performance     #we can tag any test using pytest markers, we can then run only these selected "performance" tests instead of running full suite
def test_sort_on_random_large_ints():
    items1 = [random.randint(-100000,200000) for i in range(1000000)] #elements in array are 50000 in this example with values ranging from -100000 to 200000
    print(items1)
    sorted_items = sorted(items1)  #sorting of this big array by python built-in sorting() function
    assert sort(items1) == sorted_items #comparing the output of sort algorithm versus output of python built-in sorting function





'''TEST_CASE_18: Performance Test by passing a large size floating point array: This test takes in a big size array with floating point as input types generated by random function, 
number of elements in the array is defined by the range function and run them against sorting algorithm. 
Algortithm should return sorted version of the passed unsorted array in a reasonable time. For generating expected output, I have used Python built-in function - sorted()
So in summary, this test passes unsorted array to python built-in function [sorted()] and chosen sorting algorithm and expected result is both their outputs
are sorted and matches with each other'''
@pytest.mark.performance
def test_sort_on_random_large_floats():
    items1 = [round(random.uniform(-600.98,900.45789), 8) for i in range(1000000)] #elements in array are 40000 in this example with values ranging from -600.98 to 900.45789, rounded to 8 decimal places
    print(items1)
    sorted_items = sorted(items1)  #sorting of this big array by python built-in sorting() function
    assert sort(items1) == sorted_items #comparing the output of sort algorithm versus output of python built-in sorting function






